#=

These functions were generated by the Claude 3.7 LLM.
Prompt:
> Could you write me a Julia function using the Dates standard library that can accept a flexible natural language input string and return the date time in Unix epoch seconds? The date should be the current date, but the time is given by the user. If the time is in the future, round it back to the previous day. 
> Some examples that should parse are “2am” and “18:30” . Times written as words eg “twelve am” or “noon” do not need to be supported. 
> Aim to balance flexibility of input with not over complicating the function. Try to keep it under 100 lines.

I then modified the code to not assume *today* but a given passed in date

- William

=#

using Dates

"""
    parse_time_to_epoch(time_str::String)

Parse a time string and return Unix epoch seconds.
Uses current date with the time provided.
If time is in the future, it rounds back to the previous day.

Supported formats:
- 12-hour clock: "2am", "2pm", "2:30am", "2:30pm", "2 am", "2 pm"
- 24-hour clock: "14", "14:30"

Examples:
Get Unix epoch for 2:00 AM today (or yesterday if it's already past 2 AM)
parse_time_to_epoch("2am")
Get Unix epoch for 6:30 PM today (or yesterday if it's already past 6:30 PM)
parse_time_to_epoch("18:30")
"""
function parse_time_to_epoch(time_str::String, ref_datetime::DateTime=now())
    
    # Extract just the date part (without time)
    ref_date = Date(ref_datetime)
    
    # Parse the time string
    hours, minutes = parse_time_str(time_str)
    
    # Create a DateTime with the ref date and the parsed time
    target_datetime = DateTime(year(ref_date), month(ref_date), day(ref_date), 
                             hours, minutes, 0)
    
    # # If the target datetime is in the future, subtract one day
    # if target_datetime > ref_datetime
    #     target_datetime = target_datetime - Day(1)
    # end
    
    # Convert to Unix epoch seconds
    epoch_seconds = datetime2unix(target_datetime)
    
    return epoch_seconds
end

"""
    parse_time_str(time_str::String)

Parse a time string and return the hour and minute components.
Returns a tuple of (hours, minutes).
"""
function parse_time_str(time_str::String)
    # Remove any whitespace and normalize format
    time_str = strip(time_str)
    time_str = replace(time_str, r"\s+([aApP][mM])$" => s"\1")
    
    # Pattern for 12-hour clock with AM/PM
    am_pm_pattern = r"^(\d{1,2})(?::(\d{1,2}))?([aApP][mM])$"
    
    # Pattern for 24-hour clock
    hour_minute_pattern = r"^(\d{1,2})(?::(\d{1,2}))?$"
    
    if match(am_pm_pattern, time_str) !== nothing
        # 12-hour format with AM/PM
        m = match(am_pm_pattern, time_str)
        hours = parse(Int, m[1])
        minutes = m[2] !== nothing ? parse(Int, m[2]) : 0
        am_pm = lowercase(m[3])
        
        # Validate 12-hour clock hours
        if hours < 1 || hours > 12
            throw(ArgumentError("In 12-hour clock format, hours must be between 1 and 12"))
        end
        
        # Adjust hours for AM/PM
        if am_pm == "pm" && hours < 12
            hours += 12
        elseif am_pm == "am" && hours == 12
            hours = 0
        end
        
    elseif match(hour_minute_pattern, time_str) !== nothing
        # 24-hour format
        m = match(hour_minute_pattern, time_str)
        hours = parse(Int, m[1])
        minutes = m[2] !== nothing ? parse(Int, m[2]) : 0
        
        # Validate 24-hour clock hours
        if hours < 0 || hours > 23
            throw(ArgumentError("In 24-hour clock format, hours must be between 0 and 23"))
        end
        
    else
        throw(ArgumentError("Unsupported time format: $time_str"))
    end
    
    # Validate minutes
    if minutes < 0 || minutes > 59
        throw(ArgumentError("Minutes must be between 0 and 59"))
    end
    
    return hours, minutes
end